// Code generated by goagen v1.4.3, DO NOT EDIT.
//
// API "feedpushr": Application Contexts
//
// Command:
// $ goagen
// --design=github.com/ncarlier/feedpushr/v3/design
// --out=/home/nicolas/workspace/fe/feedpushr/autogen
// --version=v1.4.3

package app

import (
	"context"
	"github.com/goadesign/goa"
	"net/http"
	"strconv"
)

// GetExploreContext provides the explore get action context.
type GetExploreContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Q *string
}

// NewGetExploreContext parses the incoming request URL and body, performs validations and creates the
// context used by the explore controller get action.
func NewGetExploreContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetExploreContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetExploreContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramQ := req.Params["q"]
	if len(paramQ) > 0 {
		rawQ := paramQ[0]
		rctx.Q = &rawQ
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetExploreContext) OK(r ExploreResponseCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.feedpushr.explore.v2+json; type=collection")
	}
	if r == nil {
		r = ExploreResponseCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *GetExploreContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// CreateFeedContext provides the feed create action context.
type CreateFeedContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Enable *bool
	Tags   *string
	Title  *string
	URL    string
}

// NewCreateFeedContext parses the incoming request URL and body, performs validations and creates the
// context used by the feed controller create action.
func NewCreateFeedContext(ctx context.Context, r *http.Request, service *goa.Service) (*CreateFeedContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := CreateFeedContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramEnable := req.Params["enable"]
	if len(paramEnable) > 0 {
		rawEnable := paramEnable[0]
		if enable, err2 := strconv.ParseBool(rawEnable); err2 == nil {
			tmp1 := &enable
			rctx.Enable = tmp1
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("enable", rawEnable, "boolean"))
		}
	}
	paramTags := req.Params["tags"]
	if len(paramTags) > 0 {
		rawTags := paramTags[0]
		rctx.Tags = &rawTags
	}
	paramTitle := req.Params["title"]
	if len(paramTitle) > 0 {
		rawTitle := paramTitle[0]
		rctx.Title = &rawTitle
	}
	paramURL := req.Params["url"]
	if len(paramURL) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("url"))
	} else {
		rawURL := paramURL[0]
		rctx.URL = rawURL
		if err2 := goa.ValidateFormat(goa.FormatURI, rctx.URL); err2 != nil {
			err = goa.MergeErrors(err, goa.InvalidFormatError(`url`, rctx.URL, goa.FormatURI, err2))
		}
	}
	return &rctx, err
}

// Created sends a HTTP response with status code 201.
func (ctx *CreateFeedContext) Created(r *FeedResponse) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 201, r)
}

// CreatedLink sends a HTTP response with status code 201.
func (ctx *CreateFeedContext) CreatedLink(r *FeedResponseLink) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 201, r)
}

// CreatedTiny sends a HTTP response with status code 201.
func (ctx *CreateFeedContext) CreatedTiny(r *FeedResponseTiny) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 201, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *CreateFeedContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// DeleteFeedContext provides the feed delete action context.
type DeleteFeedContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID string
}

// NewDeleteFeedContext parses the incoming request URL and body, performs validations and creates the
// context used by the feed controller delete action.
func NewDeleteFeedContext(ctx context.Context, r *http.Request, service *goa.Service) (*DeleteFeedContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := DeleteFeedContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *DeleteFeedContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *DeleteFeedContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *DeleteFeedContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// GetFeedContext provides the feed get action context.
type GetFeedContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID string
}

// NewGetFeedContext parses the incoming request URL and body, performs validations and creates the
// context used by the feed controller get action.
func NewGetFeedContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetFeedContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetFeedContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetFeedContext) OK(r *FeedResponse) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKLink sends a HTTP response with status code 200.
func (ctx *GetFeedContext) OKLink(r *FeedResponseLink) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKTiny sends a HTTP response with status code 200.
func (ctx *GetFeedContext) OKTiny(r *FeedResponseTiny) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *GetFeedContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *GetFeedContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// ListFeedContext provides the feed list action context.
type ListFeedContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Page int
	Q    *string
	Size int
}

// NewListFeedContext parses the incoming request URL and body, performs validations and creates the
// context used by the feed controller list action.
func NewListFeedContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListFeedContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListFeedContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramPage := req.Params["page"]
	if len(paramPage) == 0 {
		rctx.Page = 1
	} else {
		rawPage := paramPage[0]
		if page, err2 := strconv.Atoi(rawPage); err2 == nil {
			rctx.Page = page
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("page", rawPage, "integer"))
		}
		if rctx.Page < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`page`, rctx.Page, 1, true))
		}
	}
	paramQ := req.Params["q"]
	if len(paramQ) > 0 {
		rawQ := paramQ[0]
		rctx.Q = &rawQ
	}
	paramSize := req.Params["size"]
	if len(paramSize) == 0 {
		rctx.Size = 10
	} else {
		rawSize := paramSize[0]
		if size, err2 := strconv.Atoi(rawSize); err2 == nil {
			rctx.Size = size
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("size", rawSize, "integer"))
		}
		if rctx.Size < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`size`, rctx.Size, 1, true))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListFeedContext) OK(r *FeedsPageResponse) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *ListFeedContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ListFeedContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// StartFeedContext provides the feed start action context.
type StartFeedContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID string
}

// NewStartFeedContext parses the incoming request URL and body, performs validations and creates the
// context used by the feed controller start action.
func NewStartFeedContext(ctx context.Context, r *http.Request, service *goa.Service) (*StartFeedContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := StartFeedContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// Accepted sends a HTTP response with status code 202.
func (ctx *StartFeedContext) Accepted() error {
	ctx.ResponseData.WriteHeader(202)
	return nil
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *StartFeedContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *StartFeedContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// StopFeedContext provides the feed stop action context.
type StopFeedContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID string
}

// NewStopFeedContext parses the incoming request URL and body, performs validations and creates the
// context used by the feed controller stop action.
func NewStopFeedContext(ctx context.Context, r *http.Request, service *goa.Service) (*StopFeedContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := StopFeedContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// Accepted sends a HTTP response with status code 202.
func (ctx *StopFeedContext) Accepted() error {
	ctx.ResponseData.WriteHeader(202)
	return nil
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *StopFeedContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *StopFeedContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// UpdateFeedContext provides the feed update action context.
type UpdateFeedContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID    string
	Tags  *string
	Title *string
}

// NewUpdateFeedContext parses the incoming request URL and body, performs validations and creates the
// context used by the feed controller update action.
func NewUpdateFeedContext(ctx context.Context, r *http.Request, service *goa.Service) (*UpdateFeedContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := UpdateFeedContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	paramTags := req.Params["tags"]
	if len(paramTags) > 0 {
		rawTags := paramTags[0]
		rctx.Tags = &rawTags
	}
	paramTitle := req.Params["title"]
	if len(paramTitle) > 0 {
		rawTitle := paramTitle[0]
		rctx.Title = &rawTitle
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *UpdateFeedContext) OK(r *FeedResponse) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKLink sends a HTTP response with status code 200.
func (ctx *UpdateFeedContext) OKLink(r *FeedResponseLink) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKTiny sends a HTTP response with status code 200.
func (ctx *UpdateFeedContext) OKTiny(r *FeedResponseTiny) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *UpdateFeedContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *UpdateFeedContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// SpecsFilterContext provides the filter specs action context.
type SpecsFilterContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewSpecsFilterContext parses the incoming request URL and body, performs validations and creates the
// context used by the filter controller specs action.
func NewSpecsFilterContext(ctx context.Context, r *http.Request, service *goa.Service) (*SpecsFilterContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := SpecsFilterContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *SpecsFilterContext) OK(r FilterSpecResponseCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.feedpushr.filter-spec.v2+json; type=collection")
	}
	if r == nil {
		r = FilterSpecResponseCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// GetHealthContext provides the health get action context.
type GetHealthContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewGetHealthContext parses the incoming request URL and body, performs validations and creates the
// context used by the health controller get action.
func NewGetHealthContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetHealthContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetHealthContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetHealthContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// GetIndexContext provides the index get action context.
type GetIndexContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewGetIndexContext parses the incoming request URL and body, performs validations and creates the
// context used by the index controller get action.
func NewGetIndexContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetIndexContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetIndexContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetIndexContext) OK(r *Info) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// GetOpmlContext provides the opml get action context.
type GetOpmlContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewGetOpmlContext parses the incoming request URL and body, performs validations and creates the
// context used by the opml controller get action.
func NewGetOpmlContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetOpmlContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetOpmlContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetOpmlContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/xml")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *GetOpmlContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// StatusOpmlContext provides the opml status action context.
type StatusOpmlContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID int
}

// NewStatusOpmlContext parses the incoming request URL and body, performs validations and creates the
// context used by the opml controller status action.
func NewStatusOpmlContext(ctx context.Context, r *http.Request, service *goa.Service) (*StatusOpmlContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := StatusOpmlContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		if id, err2 := strconv.Atoi(rawID); err2 == nil {
			rctx.ID = id
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("id", rawID, "integer"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *StatusOpmlContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/event-stream")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// NotFound sends a HTTP response with status code 404.
func (ctx *StatusOpmlContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// UploadOpmlContext provides the opml upload action context.
type UploadOpmlContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewUploadOpmlContext parses the incoming request URL and body, performs validations and creates the
// context used by the opml controller upload action.
func NewUploadOpmlContext(ctx context.Context, r *http.Request, service *goa.Service) (*UploadOpmlContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := UploadOpmlContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// Accepted sends a HTTP response with status code 202.
func (ctx *UploadOpmlContext) Accepted(r *OPMLImportJobResponse) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 202, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *UploadOpmlContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// CreateOutputContext provides the output create action context.
type CreateOutputContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *CreateOutputPayload
}

// NewCreateOutputContext parses the incoming request URL and body, performs validations and creates the
// context used by the output controller create action.
func NewCreateOutputContext(ctx context.Context, r *http.Request, service *goa.Service) (*CreateOutputContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := CreateOutputContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// createOutputPayload is the output create action payload.
type createOutputPayload struct {
	// Alias of the output
	Alias *string `form:"alias,omitempty" json:"alias,omitempty" yaml:"alias,omitempty" xml:"alias,omitempty"`
	// Conditional expression of the output
	Condition *string `form:"condition,omitempty" json:"condition,omitempty" yaml:"condition,omitempty" xml:"condition,omitempty"`
	// Name of the output
	Name *string `form:"name,omitempty" json:"name,omitempty" yaml:"name,omitempty" xml:"name,omitempty"`
	// Output properties
	Props map[string]interface{} `form:"props,omitempty" json:"props,omitempty" yaml:"props,omitempty" xml:"props,omitempty"`
}

// Validate runs the validation rules defined in the design.
func (payload *createOutputPayload) Validate() (err error) {
	if payload.Alias == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "alias"))
	}
	if payload.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "name"))
	}
	if payload.Condition == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "condition"))
	}
	return
}

// Publicize creates CreateOutputPayload from createOutputPayload
func (payload *createOutputPayload) Publicize() *CreateOutputPayload {
	var pub CreateOutputPayload
	if payload.Alias != nil {
		pub.Alias = *payload.Alias
	}
	if payload.Condition != nil {
		pub.Condition = *payload.Condition
	}
	if payload.Name != nil {
		pub.Name = *payload.Name
	}
	if payload.Props != nil {
		pub.Props = payload.Props
	}
	return &pub
}

// CreateOutputPayload is the output create action payload.
type CreateOutputPayload struct {
	// Alias of the output
	Alias string `form:"alias" json:"alias" yaml:"alias" xml:"alias"`
	// Conditional expression of the output
	Condition string `form:"condition" json:"condition" yaml:"condition" xml:"condition"`
	// Name of the output
	Name string `form:"name" json:"name" yaml:"name" xml:"name"`
	// Output properties
	Props map[string]interface{} `form:"props,omitempty" json:"props,omitempty" yaml:"props,omitempty" xml:"props,omitempty"`
}

// Validate runs the validation rules defined in the design.
func (payload *CreateOutputPayload) Validate() (err error) {
	if payload.Alias == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "alias"))
	}
	if payload.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "name"))
	}
	if payload.Condition == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "condition"))
	}
	return
}

// Created sends a HTTP response with status code 201.
func (ctx *CreateOutputContext) Created(r *OutputResponse) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 201, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *CreateOutputContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// CreateFilterOutputContext provides the output createFilter action context.
type CreateFilterOutputContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID      string
	Payload *CreateFilterOutputPayload
}

// NewCreateFilterOutputContext parses the incoming request URL and body, performs validations and creates the
// context used by the output controller createFilter action.
func NewCreateFilterOutputContext(ctx context.Context, r *http.Request, service *goa.Service) (*CreateFilterOutputContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := CreateFilterOutputContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// createFilterOutputPayload is the output createFilter action payload.
type createFilterOutputPayload struct {
	// Alias of the filter
	Alias *string `form:"alias,omitempty" json:"alias,omitempty" yaml:"alias,omitempty" xml:"alias,omitempty"`
	// Conditional expression of the output
	Condition *string `form:"condition,omitempty" json:"condition,omitempty" yaml:"condition,omitempty" xml:"condition,omitempty"`
	// Name of the filter
	Name *string `form:"name,omitempty" json:"name,omitempty" yaml:"name,omitempty" xml:"name,omitempty"`
	// Filter properties
	Props map[string]interface{} `form:"props,omitempty" json:"props,omitempty" yaml:"props,omitempty" xml:"props,omitempty"`
}

// Validate runs the validation rules defined in the design.
func (payload *createFilterOutputPayload) Validate() (err error) {
	if payload.Alias == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "alias"))
	}
	if payload.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "name"))
	}
	if payload.Condition == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "condition"))
	}
	return
}

// Publicize creates CreateFilterOutputPayload from createFilterOutputPayload
func (payload *createFilterOutputPayload) Publicize() *CreateFilterOutputPayload {
	var pub CreateFilterOutputPayload
	if payload.Alias != nil {
		pub.Alias = *payload.Alias
	}
	if payload.Condition != nil {
		pub.Condition = *payload.Condition
	}
	if payload.Name != nil {
		pub.Name = *payload.Name
	}
	if payload.Props != nil {
		pub.Props = payload.Props
	}
	return &pub
}

// CreateFilterOutputPayload is the output createFilter action payload.
type CreateFilterOutputPayload struct {
	// Alias of the filter
	Alias string `form:"alias" json:"alias" yaml:"alias" xml:"alias"`
	// Conditional expression of the output
	Condition string `form:"condition" json:"condition" yaml:"condition" xml:"condition"`
	// Name of the filter
	Name string `form:"name" json:"name" yaml:"name" xml:"name"`
	// Filter properties
	Props map[string]interface{} `form:"props,omitempty" json:"props,omitempty" yaml:"props,omitempty" xml:"props,omitempty"`
}

// Validate runs the validation rules defined in the design.
func (payload *CreateFilterOutputPayload) Validate() (err error) {
	if payload.Alias == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "alias"))
	}
	if payload.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "name"))
	}
	if payload.Condition == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "condition"))
	}
	return
}

// Created sends a HTTP response with status code 201.
func (ctx *CreateFilterOutputContext) Created(r *FilterResponse) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 201, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *CreateFilterOutputContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *CreateFilterOutputContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// DeleteOutputContext provides the output delete action context.
type DeleteOutputContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID string
}

// NewDeleteOutputContext parses the incoming request URL and body, performs validations and creates the
// context used by the output controller delete action.
func NewDeleteOutputContext(ctx context.Context, r *http.Request, service *goa.Service) (*DeleteOutputContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := DeleteOutputContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *DeleteOutputContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *DeleteOutputContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *DeleteOutputContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// DeleteFilterOutputContext provides the output deleteFilter action context.
type DeleteFilterOutputContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID       string
	IDFilter string
}

// NewDeleteFilterOutputContext parses the incoming request URL and body, performs validations and creates the
// context used by the output controller deleteFilter action.
func NewDeleteFilterOutputContext(ctx context.Context, r *http.Request, service *goa.Service) (*DeleteFilterOutputContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := DeleteFilterOutputContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	paramIDFilter := req.Params["idFilter"]
	if len(paramIDFilter) > 0 {
		rawIDFilter := paramIDFilter[0]
		rctx.IDFilter = rawIDFilter
	}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *DeleteFilterOutputContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *DeleteFilterOutputContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *DeleteFilterOutputContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// GetOutputContext provides the output get action context.
type GetOutputContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID string
}

// NewGetOutputContext parses the incoming request URL and body, performs validations and creates the
// context used by the output controller get action.
func NewGetOutputContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetOutputContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetOutputContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetOutputContext) OK(r *OutputResponse) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *GetOutputContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *GetOutputContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// ListOutputContext provides the output list action context.
type ListOutputContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewListOutputContext parses the incoming request URL and body, performs validations and creates the
// context used by the output controller list action.
func NewListOutputContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListOutputContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListOutputContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListOutputContext) OK(r OutputResponseCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.feedpushr.output.v2+json; type=collection")
	}
	if r == nil {
		r = OutputResponseCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// SpecsOutputContext provides the output specs action context.
type SpecsOutputContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewSpecsOutputContext parses the incoming request URL and body, performs validations and creates the
// context used by the output controller specs action.
func NewSpecsOutputContext(ctx context.Context, r *http.Request, service *goa.Service) (*SpecsOutputContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := SpecsOutputContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *SpecsOutputContext) OK(r OutputSpecResponseCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.feedpushr.output-spec.v2+json; type=collection")
	}
	if r == nil {
		r = OutputSpecResponseCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// UpdateOutputContext provides the output update action context.
type UpdateOutputContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID      string
	Payload *UpdateOutputPayload
}

// NewUpdateOutputContext parses the incoming request URL and body, performs validations and creates the
// context used by the output controller update action.
func NewUpdateOutputContext(ctx context.Context, r *http.Request, service *goa.Service) (*UpdateOutputContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := UpdateOutputContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// updateOutputPayload is the output update action payload.
type updateOutputPayload struct {
	// Alias of the output
	Alias *string `form:"alias,omitempty" json:"alias,omitempty" yaml:"alias,omitempty" xml:"alias,omitempty"`
	// Conditional expression of the output
	Condition *string `form:"condition,omitempty" json:"condition,omitempty" yaml:"condition,omitempty" xml:"condition,omitempty"`
	// Output status
	Enabled *bool `form:"enabled,omitempty" json:"enabled,omitempty" yaml:"enabled,omitempty" xml:"enabled,omitempty"`
	// Output properties
	Props map[string]interface{} `form:"props,omitempty" json:"props,omitempty" yaml:"props,omitempty" xml:"props,omitempty"`
}

// Finalize sets the default values defined in the design.
func (payload *updateOutputPayload) Finalize() {
	var defaultEnabled = false
	if payload.Enabled == nil {
		payload.Enabled = &defaultEnabled
	}
}

// Publicize creates UpdateOutputPayload from updateOutputPayload
func (payload *updateOutputPayload) Publicize() *UpdateOutputPayload {
	var pub UpdateOutputPayload
	if payload.Alias != nil {
		pub.Alias = payload.Alias
	}
	if payload.Condition != nil {
		pub.Condition = payload.Condition
	}
	if payload.Enabled != nil {
		pub.Enabled = *payload.Enabled
	}
	if payload.Props != nil {
		pub.Props = payload.Props
	}
	return &pub
}

// UpdateOutputPayload is the output update action payload.
type UpdateOutputPayload struct {
	// Alias of the output
	Alias *string `form:"alias,omitempty" json:"alias,omitempty" yaml:"alias,omitempty" xml:"alias,omitempty"`
	// Conditional expression of the output
	Condition *string `form:"condition,omitempty" json:"condition,omitempty" yaml:"condition,omitempty" xml:"condition,omitempty"`
	// Output status
	Enabled bool `form:"enabled" json:"enabled" yaml:"enabled" xml:"enabled"`
	// Output properties
	Props map[string]interface{} `form:"props,omitempty" json:"props,omitempty" yaml:"props,omitempty" xml:"props,omitempty"`
}

// OK sends a HTTP response with status code 200.
func (ctx *UpdateOutputContext) OK(r *OutputResponse) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *UpdateOutputContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *UpdateOutputContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// UpdateFilterOutputContext provides the output updateFilter action context.
type UpdateFilterOutputContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID       string
	IDFilter string
	Payload  *UpdateFilterOutputPayload
}

// NewUpdateFilterOutputContext parses the incoming request URL and body, performs validations and creates the
// context used by the output controller updateFilter action.
func NewUpdateFilterOutputContext(ctx context.Context, r *http.Request, service *goa.Service) (*UpdateFilterOutputContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := UpdateFilterOutputContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	paramIDFilter := req.Params["idFilter"]
	if len(paramIDFilter) > 0 {
		rawIDFilter := paramIDFilter[0]
		rctx.IDFilter = rawIDFilter
	}
	return &rctx, err
}

// updateFilterOutputPayload is the output updateFilter action payload.
type updateFilterOutputPayload struct {
	// Alias of the filter
	Alias *string `form:"alias,omitempty" json:"alias,omitempty" yaml:"alias,omitempty" xml:"alias,omitempty"`
	// Conditional expression of the output
	Condition *string `form:"condition,omitempty" json:"condition,omitempty" yaml:"condition,omitempty" xml:"condition,omitempty"`
	// Filter status
	Enabled *bool `form:"enabled,omitempty" json:"enabled,omitempty" yaml:"enabled,omitempty" xml:"enabled,omitempty"`
	// Filter properties
	Props map[string]interface{} `form:"props,omitempty" json:"props,omitempty" yaml:"props,omitempty" xml:"props,omitempty"`
}

// Finalize sets the default values defined in the design.
func (payload *updateFilterOutputPayload) Finalize() {
	var defaultEnabled = false
	if payload.Enabled == nil {
		payload.Enabled = &defaultEnabled
	}
}

// Publicize creates UpdateFilterOutputPayload from updateFilterOutputPayload
func (payload *updateFilterOutputPayload) Publicize() *UpdateFilterOutputPayload {
	var pub UpdateFilterOutputPayload
	if payload.Alias != nil {
		pub.Alias = payload.Alias
	}
	if payload.Condition != nil {
		pub.Condition = payload.Condition
	}
	if payload.Enabled != nil {
		pub.Enabled = *payload.Enabled
	}
	if payload.Props != nil {
		pub.Props = payload.Props
	}
	return &pub
}

// UpdateFilterOutputPayload is the output updateFilter action payload.
type UpdateFilterOutputPayload struct {
	// Alias of the filter
	Alias *string `form:"alias,omitempty" json:"alias,omitempty" yaml:"alias,omitempty" xml:"alias,omitempty"`
	// Conditional expression of the output
	Condition *string `form:"condition,omitempty" json:"condition,omitempty" yaml:"condition,omitempty" xml:"condition,omitempty"`
	// Filter status
	Enabled bool `form:"enabled" json:"enabled" yaml:"enabled" xml:"enabled"`
	// Filter properties
	Props map[string]interface{} `form:"props,omitempty" json:"props,omitempty" yaml:"props,omitempty" xml:"props,omitempty"`
}

// OK sends a HTTP response with status code 200.
func (ctx *UpdateFilterOutputContext) OK(r *FilterResponse) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *UpdateFilterOutputContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *UpdateFilterOutputContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// PubPshbContext provides the pshb pub action context.
type PubPshbContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewPubPshbContext parses the incoming request URL and body, performs validations and creates the
// context used by the pshb controller pub action.
func NewPubPshbContext(ctx context.Context, r *http.Request, service *goa.Service) (*PubPshbContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := PubPshbContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *PubPshbContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *PubPshbContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// SubPshbContext provides the pshb sub action context.
type SubPshbContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	HubChallenge    string
	HubLeaseSeconds *int
	HubMode         string
	HubTopic        string
}

// NewSubPshbContext parses the incoming request URL and body, performs validations and creates the
// context used by the pshb controller sub action.
func NewSubPshbContext(ctx context.Context, r *http.Request, service *goa.Service) (*SubPshbContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := SubPshbContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramHubChallenge := req.Params["hub.challenge"]
	if len(paramHubChallenge) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("hub.challenge"))
	} else {
		rawHubChallenge := paramHubChallenge[0]
		rctx.HubChallenge = rawHubChallenge
	}
	paramHubLeaseSeconds := req.Params["hub.lease_seconds"]
	if len(paramHubLeaseSeconds) > 0 {
		rawHubLeaseSeconds := paramHubLeaseSeconds[0]
		if hubLeaseSeconds, err2 := strconv.Atoi(rawHubLeaseSeconds); err2 == nil {
			tmp6 := hubLeaseSeconds
			tmp5 := &tmp6
			rctx.HubLeaseSeconds = tmp5
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("hub.lease_seconds", rawHubLeaseSeconds, "integer"))
		}
	}
	paramHubMode := req.Params["hub.mode"]
	if len(paramHubMode) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("hub.mode"))
	} else {
		rawHubMode := paramHubMode[0]
		rctx.HubMode = rawHubMode
		if !(rctx.HubMode == "subscribe" || rctx.HubMode == "unsubscribe") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`hub.mode`, rctx.HubMode, []interface{}{"subscribe", "unsubscribe"}))
		}
	}
	paramHubTopic := req.Params["hub.topic"]
	if len(paramHubTopic) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("hub.topic"))
	} else {
		rawHubTopic := paramHubTopic[0]
		rctx.HubTopic = rawHubTopic
		if err2 := goa.ValidateFormat(goa.FormatURI, rctx.HubTopic); err2 != nil {
			err = goa.MergeErrors(err, goa.InvalidFormatError(`hub.topic`, rctx.HubTopic, goa.FormatURI, err2))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *SubPshbContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *SubPshbContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// GetSwaggerContext provides the swagger get action context.
type GetSwaggerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewGetSwaggerContext parses the incoming request URL and body, performs validations and creates the
// context used by the swagger controller get action.
func NewGetSwaggerContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetSwaggerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetSwaggerContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetSwaggerContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// GetVarsContext provides the vars get action context.
type GetVarsContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewGetVarsContext parses the incoming request URL and body, performs validations and creates the
// context used by the vars controller get action.
func NewGetVarsContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetVarsContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetVarsContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetVarsContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}
